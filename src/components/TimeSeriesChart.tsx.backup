import React, { useState, useEffect } from 'react';
import { View, Text, StyleSheet, Dimensions, TouchableOpacity } from 'react-native';
import axios from 'axios';

const { width } = Dimensions.get('window');

interface TimeSeriesData {
  timestamp: Date;
  value: number;
  label: string;
}

interface TimeSeriesChartProps {
  title?: string;
  dataPoints?: number;
  animationDuration?: number;
  onDataUpdate?: (data: TimeSeriesData[]) => void;
}

export const TimeSeriesChart: React.FC<TimeSeriesChartProps> = ({
  title = "Brake Pressure vs Lap Distance %",
  dataPoints = 20,
  animationDuration = 1000,
  onDataUpdate
}) => {
  const [data, setData] = useState<TimeSeriesData[]>([]);
  const [csvData, setCsvData] = useState<TimeSeriesData[]>([]);
  const [isAnimating, setIsAnimating] = useState(false);
  const [viewportStart, setViewportStart] = useState(0);
  const viewportWidth = 3; // View 3% at a time

  // Load CSV data
  const loadCsvData = async () => {
    try {
      const response = await axios.get('/sample_data/sample_lap.csv');
      const csvText = response.data as string;
      const lines = csvText.split('\n').filter((line: string) => line.trim() !== '');
      const headers = lines[0].split(',');

      const lapDistPctIndex = headers.indexOf('LapDistPct');
      const brakeIndex = headers.indexOf('Brake');

      const parsedData: TimeSeriesData[] = [];

      for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split(',');
        if (values.length > Math.max(lapDistPctIndex, brakeIndex)) {
          const lapDistPct = parseFloat(values[lapDistPctIndex]);
          const brake = parseFloat(values[brakeIndex]);

          if (!isNaN(lapDistPct) && !isNaN(brake)) {
            parsedData.push({
              timestamp: new Date(), // Not used for plotting, just for interface compatibility
              value: brake, // Raw brake value (0-1 scale)
              label: `${(lapDistPct * 100).toFixed(2)}%` // LapDistPct as percentage
            });
          }
        }
      }

      // Sort by LapDistPct to ensure proper ordering
      parsedData.sort((a, b) => {
        const aPct = parseFloat(a.label.replace('%', ''));
        const bPct = parseFloat(b.label.replace('%', ''));
        return aPct - bPct;
      });

      console.log(`Loaded ${parsedData.length} data points from CSV`);
      console.log(`Brake range: ${Math.min(...parsedData.map(d => d.value)).toFixed(4)} - ${Math.max(...parsedData.map(d => d.value)).toFixed(4)}`);
      setCsvData(parsedData);
      updateViewportData(parsedData, 0);
      onDataUpdate?.(parsedData);
    } catch (error) {
      console.error('Failed to load CSV data, using generated data:', error);
      initializeData();
    }
  };

  // Update viewport data based on start position
  const updateViewportData = (allData: TimeSeriesData[], startPct: number) => {
    if (title.includes("Brake")) {
      // For brake chart, show all data at once
      setData(allData);
    } else {
      // For demo charts, use viewport logic
      const endPct = startPct + viewportWidth;
      const viewportData = allData.filter(item => {
        const lapPct = parseFloat(item.label.replace('%', ''));
        return lapPct >= startPct && lapPct < endPct;
      });
      console.log(`Viewport ${startPct.toFixed(2)}% - ${endPct.toFixed(2)}%: ${viewportData.length} points`);
      setData(viewportData);
    }
    onDataUpdate?.(allData);
  };

  // Fallback data generation for demo charts
  const initializeData = () => {
    const baseTime = new Date();
    const initialData: TimeSeriesData[] = [];
    for (let i = 0; i < dataPoints; i++) {
      initialData.push({
        timestamp: baseTime,
        value: Math.random() * 100,
        label: `${i}`
      });
    }
    setData(initialData);
    setCsvData(initialData);
    onDataUpdate?.(initialData);
  };

  // Start animation - scrolls through the lap (only for demo charts)
  const startAnimation = () => {
    if (isAnimating || csvData.length === 0 || title.includes("Brake")) return;

    setIsAnimating(true);
    let currentStart = viewportStart;

    const animationRef = setInterval(() => {
      currentStart += 0.1;

      if (currentStart >= 100 - viewportWidth) {
        currentStart = 0;
      }

      setViewportStart(currentStart);
      updateViewportData(csvData, currentStart);
    }, animationDuration);

    return () => clearInterval(animationRef);
  };

  // Stop animation
  const stopAnimation = () => {
    setIsAnimating(false);
    setViewportStart(0);
    if (csvData.length > 0) {
      updateViewportData(csvData, 0);
    }
  };

  useEffect(() => {
    loadCsvData();
  }, []);

  // Update viewport when csvData is loaded
  useEffect(() => {
    if (csvData.length > 0 && !isAnimating) {
      updateViewportData(csvData, viewportStart);
    }
  }, [csvData.length]);

  // Prepare data for display - brake values are 0-1, convert to 0-100% for display
  const displayData = data.map((item) => ({
    ...item,
    displayValue: item.value * 100, // Convert to percentage for display
    lapDistPct: parseFloat(item.label.replace('%', '')) // Get numeric lap percentage
  }));

  // For brake chart, show all data; for demo charts, use viewport logic
  const chartData = title.includes("Brake") ?
    displayData.slice(0, 500) : // Limit to first 500 points for performance
    displayData;

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.title}>{title}</Text>
        {!title.includes("Brake") && (
          <View style={styles.controls}>
            <TouchableOpacity
              style={[styles.button, !isAnimating && styles.buttonActive]}
              onPress={startAnimation}
              disabled={isAnimating}
            >
              <Text style={styles.buttonText}>Animate</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[styles.button, isAnimating && styles.buttonActive]}
              onPress={stopAnimation}
              disabled={!isAnimating}
            >
              <Text style={styles.buttonText}>Stop</Text>
            </TouchableOpacity>
          </View>
        )}
      </View>

      <View style={styles.chartContainer}>
        <View style={styles.simpleChart}>
          {/* Y-axis labels */}
          <View style={styles.yAxis}>
            {[100, 80, 60, 40, 20, 0].map((value) => (
              <Text key={value} style={styles.yAxisLabel}>{value}%</Text>
            ))}
          </View>

          {/* Chart area */}
          <View style={styles.chartArea}>
            <View style={styles.lineChart}>
              {/* Draw connecting lines */}
              {chartData.length > 1 && chartData.map((item, index) => {
                if (index === 0) return null;
                const prevItem = chartData[index - 1];

                // X position based on lap distance percentage (0-100% mapped to chart width)
                const chartWidth = width - 120;
                const x1 = title.includes("Brake") ?
                  (prevItem.lapDistPct / 100) * chartWidth :
                  ((prevItem.lapDistPct - viewportStart) / viewportWidth) * chartWidth;
                const x2 = title.includes("Brake") ?
                  (item.lapDistPct / 100) * chartWidth :
                  ((item.lapDistPct - viewportStart) / viewportWidth) * chartWidth;

                // Y position based on value (0-1 mapped to chart height, inverted)
                const chartHeight = 200;
                const y1 = chartHeight - (prevItem.value * chartHeight);
                const y2 = chartHeight - (item.value * chartHeight);

                const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                if (length < 1) return null; // Skip very short lines

                const angle = Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);
                const centerX = 60 + (x1 + x2) / 2;
                const centerY = (y1 + y2) / 2;

                return (
                  <View
                    key={`line-${index}`}
                    style={[
                      styles.lineSegment,
                      {
                        left: centerX - length / 2,
                        top: Math.max(0, Math.min(chartHeight - 2, centerY - 1)),
                        width: length,
                        transform: [{ rotate: `${angle}deg` }],
                        backgroundColor: isAnimating ? '#2196f3' : '#666',
                      },
                    ]}
                  />
                );
              })}
            </View>

            {/* X-axis labels */}
            <View style={styles.xAxis}>
              {[0, 25, 50, 75, 100].map((pct) => {
                const x = 60 + (pct / 100) * (width - 120);
                return (
                  <Text key={`x-${pct}`} style={[styles.xAxisLabel, { left: x - 15 }]}>
                    {pct}%
                  </Text>
                );
              })}
            </View>
          </View>
        </View>
      </View>

      <View style={styles.stats}>
        <Text style={styles.statsText}>
          Max Brake: {data.length > 0 ? (Math.max(...data.map(d => d.value)) * 100).toFixed(1) : '0.0'}%
        </Text>
        <Text style={styles.statsText}>
          Avg Brake: {data.length > 0 ? ((data.reduce((sum, d) => sum + d.value, 0) / data.length) * 100).toFixed(1) : '0.0'}%
        </Text>
        <Text style={styles.statsText}>
          Data Points: {data.length}
        </Text>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    backgroundColor: '#1e1e1e',
    borderRadius: 16,
    padding: 16,
    margin: 16,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 4,
    elevation: 5,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
  },
  title: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#ffffff',
  },
  controls: {
    flexDirection: 'row',
    gap: 8,
  },
  button: {
    backgroundColor: '#333',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 8,
    minWidth: 60,
    alignItems: 'center',
  },
  buttonActive: {
    backgroundColor: '#2196f3',
  },
  buttonText: {
    color: '#ffffff',
    fontSize: 12,
    fontWeight: '600',
  },
  chartContainer: {
    alignItems: 'center',
    overflow: 'hidden',
  },
  simpleChart: {
    flexDirection: 'row',
    backgroundColor: '#1a1a1a',
    borderRadius: 16,
    padding: 20,
    marginVertical: 8,
    width: width - 40,
    height: 300,
  },
  chartArea: {
    flex: 1,
    position: 'relative',
  },
  lineChart: {
    position: 'relative',
    width: '100%',
    height: 200,
  },
  lineSegment: {
    position: 'absolute',
    height: 2,
    backgroundColor: '#2196f3',
  },
  yAxis: {
    width: 50,
    justifyContent: 'space-between',
    alignItems: 'flex-end',
    paddingRight: 10,
    paddingTop: 20,
  },
  yAxisLabel: {
    fontSize: 12,
    color: '#cccccc',
    textAlign: 'right',
  },
  xAxis: {
    position: 'absolute',
    bottom: 0,
    left: 60,
    right: 0,
    height: 30,
  },
  xAxisLabel: {
    position: 'absolute',
    fontSize: 12,
    color: '#cccccc',
    textAlign: 'center',
    width: 30,
  },
  stats: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    marginTop: 16,
    paddingTop: 16,
    borderTopWidth: 1,
    borderTopColor: '#333',
  },
  statsText: {
    color: '#cccccc',
    fontSize: 12,
  },
});
